
Dynamic Primer Highlighting was suggested early on in the requirements
elicitation process by the clients as something that would be very
helpful to students studying primer design. The initial specification
for this feature was as follows:

\begin{itemize}	
\item“As the user enters their choice of primer in one of the boxes at the
top of the page, instances of the primer should be highlighted in
real-time in the corresponding box below containing the DNA sequence for
the strand on which this primer should appear.”
\end{itemize}

In a later client meeting the following addition was made to improve the
effectiveness of the feature:

\begin{itemize}
\item“Primers should be highlighted in different colours to indicate their
suitability.”
\end{itemize}

This was a feature that all members of the team appreciated from a very early
stage because, even with our limited knowledge about primer design we
could see how this form of immediate feedback had the potential to
improve the usability of the system if it were to be implemented well.
Due to this level of popularity among both the clients and the team
members the feature was given high priority. However, since we knew it
would be complex to implement and would require calls to other planned
modules of the system, such as the primer checking functions, it was
also decided that this should be one of the last features to be
implement.

This feature turned out to be one of the most problematic features to
implement as it involved using features of Java which we had no real
experience with, specifically the Swing classes \texttt{ChangeListener},
\texttt{Highlighter} and \texttt{Painter} as well as integrating other
modules of our code to provide the required primer checking. This level
of difficulty meant that this feature actually took multiple attempts to
implement correctly.

\subsubsection{Implementation}

The implementation of this feature can be split into two main components:

\begin{itemize}
\item The code to listen for user input in the primer entry text fields
and call the appropriate methods to deal with the input.
\item The runnable objects \texttt{searchO} and \texttt{searchC} which
are called by the listener and update the highlighted text.
\end{itemize}

\subsubsection{Listening for Input}

The first challenge we were met with when implementing this feature was
deciding how to listen for user input in the
\texttt{forwardPrimerTextField} and \texttt{reversePrimerTextField}.

Due to the fact that only one strand's display tab would be shown at any
given time, only the TextField related to the active tab would have to
be listened to and any user input in the other field could be ignored
until the active tab changed. This meant that only one listener would be
needed and the TextField it was listening for updates on could be
switched when required.

Since this feature was implemented late on in the development cycle,
code already existed to deal with changes upon switching tabs.
Therefore, we were able to add the calls to switch the TextField being
listened to into the existing \texttt{updateLineNums()} function which
was only being used to update the line numbers upon switching between
single and double-stranded views.

As well as switching the target of the listener upon switching tabs, a
a call must be made to the search function related to the new tab
since any user input into the corresponding TextField while the tab was
not active will not yet be reflected in the display tab. This call is
made using and \texttt{invokeLater()} call of the runnable search
function as oppposed to a standard \texttt{invoke()} call to allow the
system to continue listening for updates if a call to one of the search
functions takes a long time to process.

Once we had worked out how we were going to switch the listener focus
all that was left to do in terms of listening for input was to add code
to the \texttt{DocumentListener} functions \texttt{insertUpdate()} and
\texttt{removeUpdate()} to run the appropriate search function. All this
required was an if statement to determine the source of the update and
inside the if statement a call to the appropriate search.

\subsubsection{Runnable Search Functions}

After dealing with listening for user input, the next task was to create
the functions to search for the user's primer in the DNA sequence and
highlight the appropriate sections.

To perform this task we created two similar methods: \texttt{searchO()}
to search the parsed original strand, \texttt{parsedO}, and update forward
primer highlights and \texttt{searchC()} to search the parsed
complementary strand, \texttt{parsedC}, and update reverse primer
highlights.

The first task these functions perform is to remove all existing
highlights from the display. The other option here was to keep a list of
all highlights and their positions in the sequence then check each one
individually to determine if they were still valid after the latest
input and highlight an extra base at the start of end of the old
highlight. This list based solution was not chosen because, for example,
if a user's first input was a single letter then the program would
potentially have to store the positions of thousands of bases and
perform thousands of comparisons on their next input.

The next step is to get the position of the first instance of the primer
in the sequence using the java \texttt{indexOf()} function. This is then
used as part of the condition of the while loop which carries out most
of the functionality in these methods. The while loop is excecuted while
the result of the \texttt{indexOf()} call is not negative (i.e. the
primer is found in the text being searched) and the user input has a
length greater than 0 (i.e. The call to the function was not because the
user deleted everything in the text field).

Inside the while loop the colour to highlight the current instance is
determined by the following if statement from \texttt{searchC}:

\begin{lstlisting}
    if (sC.length() > 15){
        Primer rPrimer = new Primer(Primer.reverse(sC));
        rTest = new model.TestResult();
        rTest.addFull(rPrimer.test());
        rTest.add(
            rPrimer.isUnique(PrimerDesign.start.getInSequence(),
                'c'));
        if (rTest.perfect()){
            activePaint = perfectPaint;
        } else if (rTest.acceptable()){
            activePaint = acceptPaint;
        } else {
            activePaint = failPaint;
        }
    } else {
        activePaint = failPaint;
    } 
\end{lstlisting}

Here, \texttt{sC} is the user's primer input and \texttt{perfectPaint},
\texttt{acceptPaint} and \texttt{failPaint} are different coloured
\texttt{Painter} objects initialised when \texttt{PrimerSelectionPanel}
is first loaded. The only difference between the three \texttt{Painter}
objects is their colour with \texttt{perfectPaint} being blue,
\texttt{acceptPaint} being yellow and \texttt{failPaint} being red.
These were initially green, yellow and red but green was eventually
substituted for cyan due to concerns about colour-blind users.

The late stage at which this feature was implemented meant that the
process of evaluating the user's primer was a trivial task as all the
methods check the primer were already written, as were the methods to
evaluate the success of the primer overall. So the method simply has to
create a new \texttt{Primer} instance with the user's input and create
an instance of \texttt{TestResult} to store the results of the primer
checking methods. Then the method calls the \texttt{perfect()} and
\texttt{acceptable()} methods to determine the colour the primer should
be highlighted.

Once the colour of highlight has been determined the highlight is
applied to the correct section of the DNA sequence using the following
code:

\begin{lstlisting}
    endC = indexC + sC.length();
    highC.addHighlight(realIndex(indexC + checked, 10),
        realIndex(endC + checked, 10), activePaint);
\end{lstlisting}

\texttt{endC} is calculated by adding the length of the user's primer to
the index of the current instance of the primer in the sequence, 
\texttt{indexC}. \texttt{realIndex} is a function which converts the
indices in the parsed sequence into the indices needed for displaying
the highlights in the display panes.

Once the current instance of the primer has been highlighted, a 
\texttt{substring()} is performed on the relevant parsed sequence to
remove everything up to the end of the current primer instance. The
index of the first instance of the primer in this new, shorter sequence
is then found and if this index is greater than or equal to 0 then the
while executes again to highlight this new instance of the primer.

After all instances have been highlighted the parsed sequence is reset
to the state it was in before the function was called.











